<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bhoot Chaturdashi</title>
    
    <!-- Load Tailwind CSS for styling the page -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Load p5.js for canvas drawing and game logic -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    
    <style>
        body { font-family: 'Inter', sans-serif; overflow: hidden; }
        canvas { display: block; border: 2px solid #4a5568; border-radius: 8px; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3); }
    </style>
</head>
<body class="bg-gray-900 text-gray-100">
    <!-- Main container to center the game -->
    <main class="min-h-screen w-full flex flex-col items-center justify-center p-4">
        
        <!-- Updated Page Title -->
        <h1 class="text-2xl font-bold text-white mb-4">Bhoot Chaturdashi</h1>
        
        <!-- The p5.js canvas will be injected here -->
        <div id="canvas-container"></div>
    </main>

    <!-- 
      All game JavaScript is combined into this single script tag.
    -->
    <script>
    
    // --- Person Class ---
    class Person {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.w = 20;
            this.h = 30;
            this.speed = 3;
            this.name = "Person";
            this.isVulnerable = true;
            this.vulnerabilityTimer = 0; 
        }

        display(opacity = 255) {
            // Draw name
            fill(255, opacity);
            textAlign(CENTER);
            textSize(12);
            text(this.name, this.x, this.y - this.h / 2 - 10);
            
            // Draw body
            // Blink when not vulnerable (invincible)
            if (!this.isVulnerable && frameCount % 10 < 5) {
                // Don't draw (blink)
            } else {
                fill(0, 100, 255, opacity);
                noStroke();
                rectMode(CENTER);
                rect(this.x, this.y, this.w, this.h, 4); // Added rounded corners
            }
        }
        
        updateVulnerability() {
            if (!this.isVulnerable) {
                this.vulnerabilityTimer--;
                if (this.vulnerabilityTimer <= 0) {
                    this.isVulnerable = true;
                }
            }
        }

        // Called *after* winning the spam minigame
        registerHit() {
            if(this.isVulnerable) {
                this.isVulnerable = false;
                this.vulnerabilityTimer = 120; // 2 seconds invulnerability
            }
        }

        update(walls) {
            // Handle invulnerability timer
            this.updateVulnerability();
            
            // Don't move if spamming
            if (isSpamming) return;

            let nextX = this.x;
            let nextY = this.y;

            // Keyboard input
            if (keyIsDown(LEFT_ARROW) || keyIsDown(65)) nextX -= this.speed; // A
            if (keyIsDown(RIGHT_ARROW) || keyIsDown(68)) nextX += this.speed; // D
            if (keyIsDown(UP_ARROW) || keyIsDown(87)) nextY -= this.speed; // W
            if (keyIsDown(DOWN_ARROW) || keyIsDown(83)) nextY += this.speed; // S

            // Wall collision detection
            let isColliding = false;
            for (let wall of walls) {
                if (
                    nextX + this.w / 2 > wall.x &&
                    nextX - this.w / 2 < wall.x + wall.w &&
                    nextY + this.h / 2 > wall.y &&
                    nextY - this.h / 2 < wall.y + wall.h
                ) {
                    isColliding = true;
                    break;
                }
            }

            // Only update position if not colliding
            if (!isColliding) {
                this.x = nextX;
                this.y = nextY;
            }
        }
        
        resetPosition() {
            this.x = 50;
            this.y = 50;
        }

        collidesWith(other) {
            // Check for circle (ghost, diya)
            if (other.size) {
                 let d = dist(this.x, this.y, other.x, other.y);
                 return d < this.w / 2 + other.size / 2;
            } 
            // Check for rect (lightswitch)
            else if (other.w) {
                return (
                    this.x + this.w / 2 > other.x &&
                    this.x - this.w / 2 < other.x + other.w &&
                    this.y + this.h / 2 > other.y &&
                    this.y - this.h / 2 < other.y + other.h
                );
            }
            return false;
        }
    }
    
    // --- Diya Class ---
    class Diya {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.size = 20;
            this.name = "Diya";
            this.isLit = false;
        }

        display(isActive) {
            rectMode(CENTER);
            noStroke();
            
            // Draw light radius if lit
            if (this.isLit) {
                // Pulsing light effect
                let lightSize = 150 + sin(frameCount * 0.05) * 10;
                fill(255, 220, 0, 50); // Soft yellow alpha
                ellipse(this.x, this.y, lightSize, lightSize);
            }
            
            // Draw Diya square
            fill(isActive ? 139 : 80, isActive ? 69 : 40, isActive ? 19 : 10); // Brown or dark brown
            rect(this.x, this.y, this.size, this.size, 2);
            
            // Draw flame
            if (this.isLit) {
                fill(255, 150, 0);
                ellipse(this.x, this.y - this.size/2 + 2, 5, 10);
            }

            // Draw name
            fill(255, 255, 255, 150);
            textAlign(CENTER);
            textSize(10);
            text(this.name, this.x, this.y - this.size / 2 - 8);
        }
    }

    // --- Ghost Class ---
    class WanderingGhost {
        constructor(x, y, name) {
            this.x = x;
            this.y = y;
            this.size = 40;
            this.name = name;
            this.isVisible = true;
            this.blinkTimer = random(120, 240); // Time between blinks
            this.wanderTimer = 60; // Time before changing direction
            this.wanderSpeed = 1;
            this.vx = 0;
            this.vy = 0;
            this.opacity = 0;
        }

        update(walls) {
            // Handle Blinking
            this.blinkTimer--;
            if (this.blinkTimer <= 0) {
                this.isVisible = !this.isVisible;
                this.blinkTimer = random(120, 240); // Reset timer
            }

            // Handle Wandering
            this.wanderTimer--;
            if (this.wanderTimer <= 0) {
                // Pick a new random direction
                let angle = random(TWO_PI);
                this.vx = cos(angle) * this.wanderSpeed;
                this.vy = sin(angle) * this.wanderSpeed;
                this.wanderTimer = random(60, 180); // Wander for 1-3 seconds
            }

            // Wall collision for ghost
            let nextX = this.x + this.vx;
            let nextY = this.y + this.vy;
            let isColliding = false;

            for (let wall of walls) {
                 if (
                    nextX + this.size / 2 > wall.x &&
                    nextX - this.size / 2 < wall.x + wall.w &&
                    nextY + this.size / 2 > wall.y &&
                    nextY - this.size / 2 < wall.y + wall.h
                ) {
                    isColliding = true;
                    break;
                }
            }
            if (isColliding) {
                // Hit a wall, reverse direction
                this.vx *= -1;
                this.vy *= -1;
                this.wanderTimer = 0; // Force new direction next frame
            } else {
                this.x += this.vx;
                this.y += this.vy;
            }
        }

        display(opacity = 100) {
            if (!this.isVisible) return;
            
            fill(220, 220, 255, opacity); // Translucent white
            noStroke();
            
            ellipse(this.x, this.y, this.size, this.size);
            
            fill(255, 100, 100, opacity * 1.5);
            textAlign(CENTER);
            textSize(12);
            text(this.name, this.x, this.y - this.size / 2 - 5);
        }
    }

    // --- Environment Classes ---
    class Wall {
        constructor(x, y, w, h) {
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
        }
        display() {
            rectMode(CORNER);
            noStroke();
            fill(50, 50, 60); // Dark blue-grey
            rect(this.x, this.y, this.w, this.h);
        }
    }

    class Phone {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.size = 25;
            this.name = "Phone";
        }
        display() {
            // Draw Phone
            fill(80, 80, 80); // Dark grey
            stroke(200);
            strokeWeight(2);
            rectMode(CENTER);
            rect(this.x, this.y, this.size, this.size + 10, 5);
            
            // Screen
            fill(50, 50, 150);
            noStroke();
            rect(this.x, this.y - 5, this.size - 8, this.size - 10, 2);

            fill(255);
            textAlign(CENTER);
            textSize(12);
            text(this.name, this.x, this.y - this.size / 2 - 15);
        }
        handleCollision() {
            if (gameState === 1) {
                gameState = 2; // Move to next level
                hintText = "Hint: Light the 14 diyas by pressing 'A' near them, and avoid the ghosts.";
                hintCount = 1;
            } else if (gameState === 2 && hintCount < 2) {
                hintCount = 2;
                hintText = "Hint: The ritual seems wrong... Maybe try the light switches?";
            }
        }
    }
    
    class LightSwitch {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.w = 10;
            this.h = 25;
            this.isOn = false;
            this.name = "Switch";
        }
        display() {
            fill(255);
            textAlign(CENTER);
            textSize(10);
            text(this.name, this.x + this.w/2, this.y - 8);
            
            fill(this.isOn ? 255 : 100);
            stroke(200);
            rectMode(CORNER);
            rect(this.x, this.y, this.w, this.h, 2);
        }
        activate() {
            if (!this.isOn) {
                this.isOn = true;
                switchesActivated++;
            }
        }
    }

    // --- Global Game Variables ---
    let person;
    let ghosts = [];
    let phone;
    let walls = [];
    let diyas = [];
    let lightSwitches = [];

    // Game State Management
    let gameState = 0; // 0: Intro, 1: Maze, 2: Ritual, 3: Win, 4: Lose
    let introScene = 0; // 0: Start, 1: Black, 2: Ghost
    let introTimer = 0;
    let introOpacity = 0;
    
    let lives = 3;
    let hintCount = 0;
    let hintText = "";
    let diyasLit = 0;
    let switchesActivated = 0;

    // Spam Mini-Game Variables
    let isSpamming = false;
    const SPAM_KEY = 'k';
    const SPAM_TARGET = 10;
    const SPAM_DURATION = 7; // 7 seconds
    let spamCount = 0;
    let spamTimer = 0;


    // --- p5.js Core Functions ---
    function setup() {
        let canvas = createCanvas(640, 480); // Canvas size
        canvas.parent('canvas-container'); // Attach canvas to the div
        
        person = new Person(50, 50); // Start at top-left

        // Create Maze (4-room maze with doors)
        let wallThickness = 20;
        // Outer walls
        walls.push(new Wall(0, 0, width, wallThickness)); // Top
        walls.push(new Wall(0, height - wallThickness, width, wallThickness)); // Bottom
        walls.push(new Wall(0, 0, wallThickness, height)); // Left
        walls.push(new Wall(width - wallThickness, 0, wallThickness, height)); // Right
        
        // --- Maze internal walls ---
        // Center vertical hall walls
        walls.push(new Wall(width/2 - wallThickness/2, wallThickness, wallThickness, height/2 - 70));
        walls.push(new Wall(width/2 - wallThickness/2, height/2 + 50, wallThickness, height/2 - wallThickness - 50));
        
        // Center horizontal hall walls
        walls.push(new Wall(wallThickness, height/2 - wallThickness/2, width/2 - 70, wallThickness));
        walls.push(new Wall(width/2 + 50, height/2 - wallThickness/2, width/2 - wallThickness - 50, wallThickness));
        
        // --- Room dividers ---
        // Top-left room
        walls.push(new Wall(150, wallThickness, wallThickness, 150));
        walls.push(new Wall(80, 150, 70 + wallThickness, wallThickness));
        
        // Bottom-left room
        walls.push(new Wall(wallThickness, 350, 150, wallThickness));
        walls.push(new Wall(150, 300, wallThickness, 50));
        walls.push(new Wall(150, 410, wallThickness, 50));
        
        // Top-right room
        walls.push(new Wall(width - 150, wallThickness, wallThickness, 150));
        walls.push(new Wall(width - 220, 150, 140, wallThickness));
        
        // Bottom-right room
        walls.push(new Wall(width - 150, 300, wallThickness, 160));
        walls.push(new Wall(width - 220, 300, 70 + wallThickness, wallThickness));


        phone = new Phone(width / 2, height / 2);
        
        // Create 2 Light Switches
        lightSwitches.push(new LightSwitch(wallThickness, height / 2 - 12)); // Left wall
        lightSwitches.push(new LightSwitch(width - wallThickness - 10, height / 2 - 12)); // Right wall
        
        // Create 7 Ghosts
        for(let i = 0; i < 7; i++) {
             ghosts.push(new WanderingGhost(random(50, width-50), random(50, height-50), `Ghost ${i+1}`));
        }

        // Create 14 Diyas NOT in the hallways
        let diyaCount = 0;
        while(diyaCount < 14) {
            let x = random(50, width - 50);
            let y = random(50, height - 50);
            let validPos = true;
            
            // Check for wall collision
            for (let wall of walls) {
                if (x > wall.x && x < wall.x + wall.w && y > wall.y && y < wall.y + wall.h) {
                    validPos = false;
                    break;
                }
            }
            if (!validPos) continue;
            
            // Check for hallway collision
            let inVerticalHall = (x > width/2 - wallThickness/2 - 20 && x < width/2 + wallThickness/2 + 20);
            let inHorizontalHall = (y > height/2 - wallThickness/2 - 20 && y < height/2 + wallThickness/2 + 20);
            if (inVerticalHall || inHorizontalHall) {
                validPos = false;
            }
            
            // Check for phone collision
            if (dist(x, y, phone.x, phone.y) < 40) {
                validPos = false;
            }

            if (validPos) {
                diyas.push(new Diya(x, y));
                diyaCount++;
            }
        }
    }

    function draw() {
        // Check for spam mini-game first
        if (isSpamming) {
            drawSpamMinigame();
        } else {
            // Main game logic
            switch (gameState) {
                case 0: drawIntroSequence(); break;
                case 1: drawLevel1(); break;
                case 2: drawLevel2(); break;
                case 3: drawEndScreen(true); break; // Win
                case 4: drawEndScreen(false); break; // Lose
            }
        }
    }

    function mousePressed() {
        // No mouse actions in this version
    }

    function keyPressed() {
        if (gameState === 0) {
            if (introScene === 0) {
                introScene = 1;
                introTimer = frameCount; // Start timer for black screen
            }
        } else if (isSpamming) {
            if (key.toLowerCase() === SPAM_KEY) {
                spamCount++;
            }
        } else if (gameState === 2) {
             // Light nearest diya with 'A'
            if (key.toLowerCase() === 'a') {
                lightNearestDiya();
            }
        }
    }
    
    // --- State Drawing Functions ---

    function drawIntroSequence() {
        if (introScene === 0) {
            // Part 1: Start Screen
            background(30, 30, 40);
            textAlign(CENTER, CENTER);
            fill(255, 220, 0);
            textSize(50);
            text("Bhoot Chaturdashi", width / 2, height / 2 - 40);
            fill(200);
            textSize(20);
            if (frameCount % 60 < 30) {
                text("[ Click any key to start ]", width / 2, height / 2 + 50);
            }
        } else if (introScene === 1) {
            // Part 2: Black Screen
            background(0);
            introOpacity = lerp(introOpacity, 255, 0.05); // Fade in
            fill(200, introOpacity);
            textAlign(CENTER, CENTER);
            textSize(28);
            text("A FORGOTTEN RITUAL.", width / 2, height / 2);
            
            if (frameCount > introTimer + 180) { // 3 second timer
                introScene = 2;
                introTimer = frameCount; // Reset timer for next scene
                introOpacity = 0;
            }
        } else if (introScene === 2) {
            // Part 3: Ghost Appears
            background(50, 50, 60); // Dark room
            
            // Draw person
            person.display();
            
            // Ghost fades in
            introOpacity = lerp(introOpacity, 100, 0.02); // Fade in slowly
            fill(220, 220, 255, introOpacity);
            if (frameCount % 10 < 5) { // Flicker
                ellipse(width/2 + 100, height/2, 60, 60);
            }
            
            if (frameCount > introTimer + 180) { // 3 second timer
                gameState = 1;
            }
        }
    }

    function drawLevel1() {
        background(100); // Main game grey
        
        // Draw all static elements
        walls.forEach(wall => wall.display());
        diyas.forEach(diya => diya.display(false)); // Inactive
        phone.display();
        
        // Update and display person
        person.update(walls);
        person.display();
        // Update and display ghosts
        ghosts.forEach(ghost => {
            ghost.update(walls);
            ghost.display();
        });

        // Check for all collisions
        checkCollisions();
        
        // --- Draw UI Text INSIDE canvas ---
        drawUI();
        fill(255, 220, 0);
        textAlign(CENTER, CENTER);
        textSize(20);
        text("Objective: Get to the Phone!", width/2, 40);
    }

    function drawLevel2() {
        background(100);
        
        // Draw all static elements
        walls.forEach(wall => wall.display());
        diyas.forEach(diya => diya.display(true)); // Active
        phone.display(); // Phone is still usable for hints
        lightSwitches.forEach(sw => sw.display());
        
        // Update and display person
        person.update(walls);
        person.display();
        // Update and display ghosts
        ghosts.forEach(ghost => {
            ghost.update(walls);
            ghost.display();
        });

        // Check for all collisions
        checkCollisions();
        
        // Check Win/Lose Conditions
        if (diyasLit >= 14) {
            gameState = 4; // Lose
        }
        if (switchesActivated >= 2 && hintCount >= 2) {
            gameState = 3; // Win
        }
        
        // --- Draw UI Text INSIDE canvas ---
        drawUI();
        fill(255, 220, 0);
        textAlign(CENTER, CENTER);
        textSize(20);
        if (hintCount < 2) {
            text(`Objective: Light all 14 Diyas (${diyasLit} / 14)`, width/2, 40);
        } else {
            text(`Objective: Activate the Light Switches (${switchesActivated} / 2)`, width/2, 40);
        }
    }

    // New function to draw the Spam mini-game
    function drawSpamMinigame() {
        // Draw the level behind, but dimmed
        if (gameState === 1) drawLevel1();
        if (gameState === 2) drawLevel2();
        
        fill(0, 0, 0, 150); // Dark overlay
        rectMode(CORNER);
        rect(0, 0, width, height);
        
        // Update timer
        spamTimer--;
        
        // Check for win/lose
        if (spamCount >= SPAM_TARGET) {
            isSpamming = false;
            person.registerHit(); // Give invulnerability
        } else if (spamTimer <= 0) {
            isSpamming = false;
            lives--;
            person.registerHit(); // Give invulnerability
            person.resetPosition(); // Reset player to start
            if (lives <= 0) {
                gameState = 4; // You lose
            }
        }
        
        // Draw UI
        textAlign(CENTER, CENTER);
        fill(255, 0, 0);
        textSize(40);
        text("SPAM THE 'K' KEY!", width / 2, height / 2 - 80);
        textSize(30);
        fill(255);
        text(`Presses: ${spamCount} / ${SPAM_TARGET}`, width / 2, height / 2);
        
        // Draw timer bar
        fill(100);
        rectMode(CORNER);
        rect(width/2 - 150, height/2 + 60, 300, 30);
        fill(255, 200, 0);
        // Map timer remaining to bar width
        let barWidth = map(spamTimer, 0, SPAM_DURATION * 60, 0, 300);
        rect(width/2 - 150, height/2 + 60, barWidth, 30);
    }

    // New function to draw the shared UI elements
    function drawUI() {
        // Display Lives
        fill(255, 100, 100);
        textAlign(LEFT, TOP);
        textSize(16);
        text(`Lives: ${lives}`, 30, 30);
        
        // Display Hint Text
        fill(255, 255, 255, 200);
        textAlign(CENTER, BOTTOM);
        textSize(16);
        text(hintText, width / 2, height - 30);
        
        // Display controls
        fill(200);
        textAlign(CENTER, BOTTOM);
        textSize(14);
        text("Controls: Arrow Keys to Move. 'A' to Light Diya.", width / 2, height - 10);
    }


    function drawEndScreen(isWin) {
        background(isWin ? 255 : 0, 10); // White for win, black for lose
        textAlign(CENTER, CENTER);
        textSize(24);
        
        if (isWin) {
            fill(0, 100, 50); // Dark Green
            text("You turned on the lights. The shadows vanish.", width / 2, height / 2 - 90);
            
            fill(0); // Black text on white bg
            text("Perhaps the greatest protection... is simple logic.\nThe stories we tell are just that.\nStories.", width/2, height/2 - 20);
            
            fill(50);
            textSize(16);
            text("(You questioned the ritual and found your own light.)", width/2, height/2 + 80);

        } else {
            fill(150, 0, 0); // Dark red
            text("The ritual has failed, or perhaps... it was a trap.", width / 2, height / 2 - 90);
            
            fill(200); // White text on black bg
            text("But was it the magic, or just your own light?\nA story to tell, a fear to contain.\nThe dawn breaks, and you remain.", width/2, height/2 - 20);

            fill(180);
            textSize(16);
            text("(The ending is the same, regardless of the ritual's success.)", width/2, height/2 + 80);
        }
    }
    
    // --- Helper Functions ---
    
    function lightNearestDiya() {
        let nearestDiya = null;
        let minDist = 100; // Max range to light a diya
        
        for (let diya of diyas) {
            if (!diya.isLit) {
                let d = dist(person.x, person.y, diya.x, diya.y);
                if (d < minDist) {
                    minDist = d;
                    nearestDiya = diya;
                }
            }
        }
        
        if (nearestDiya) {
            nearestDiya.isLit = true;
            diyasLit = diyas.filter(d => d.isLit).length;
        }
    }

    function checkCollisions() {
        if (isSpamming) return; // Don't check collisions while spamming

        // Check ghost collisions
        for (let ghost of ghosts) {
            if (ghost.isVisible && person.collidesWith(ghost)) {
                if (person.isVulnerable) {
                    isSpamming = true;
                    spamCount = 0;
                    spamTimer = SPAM_DURATION * 60; // 7 seconds
                    break;
                }
            }
        }

        // Check phone collision
        if (person.collidesWith(phone)) {
            phone.handleCollision();
        }
        
        // Check light switch collision (only in state 2)
        if (gameState === 2) {
            for (let sw of lightSwitches) {
                if (!sw.isOn && person.collidesWith(sw)) {
                    sw.activate();
                }
            }
        }
    }
    
    </script>
    
</body>
</html>